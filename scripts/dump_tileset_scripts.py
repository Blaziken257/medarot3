#!/bin/python

# Script to initially dump tileset scripts

import os, sys
from collections import OrderedDict
from functools import partial
from pathlib import Path

sys.path.append(os.path.join(os.path.dirname(__file__), 'common'))
from common import utils, tilesets, png, gfx

raw_path = sys.argv[1]
gfx_output_path = sys.argv[2]
scripts_res_path = sys.argv[3]
gfx_src_path = sys.argv[4]

roms = ([
            ("baserom_kabuto.gbc", "kabuto"), 
            ("baserom_kuwagata.gbc", "kuwagata")
        ])

instruction_roots = ([
        (0x2e, 0x4000),
        (0x63, 0x4000)
    ])

output_file = os.path.join(gfx_src_path, "tileset_scripts.asm")

nametable = {}


commands = {}
class TilesetCommand():
    def __init__(self, name, bts = 1, parser=None, is_end = False):
        self.name = name
        self.bts = bts
        if not parser:
            parser = { 0: lambda x: None, 1: utils.read_byte, 2: utils.read_short }[self.bts]
        self.parser = parser
        self.is_end = is_end

commands[0xFB] = TilesetCommand("TilesetSetVRAMBank") # FB XX, set active VRAM bank
commands[0xFC] = TilesetCommand("TilesetRunPreset") # FC XX, loads preset command from table
commands[0xFD] = TilesetCommand("TilesetSetGraphicsBank") # FD XX, set source bank to load tiles from
commands[0xFE] = TilesetCommand("TilesetSetVRAMIndex") # FE XX, set destination index in VRAM to draw to
commands[0xFF] = TilesetCommand("TilesetEnd", bts = 0, is_end = True) # FF, end script
commands[None] = TilesetCommand("TilesetRender", bts = 2, parser = utils.read_byte) # XX YY, No command specified, render XX tiles from index YY in the source graphics table

version = roms[0]
version_suffix = version[1]

with open(output_file, 'w') as output:
    output.write(f"; Autogenerated by {sys.argv[0]}\n\n")
    for symbol in commands:
        command = commands[symbol]
        output.write(f"{command.name}: MACRO\n")
        if symbol:
            output.write(f"  db ${symbol:02X}\n")
        for i in range(command.bts):
            output.write(f"  db \\{i + 1}\n")
        output.write("  ENDM\n\n")

    with open(version[0], "rb") as rom:
        for root_idx, root in enumerate(instruction_roots):
            addr = utils.rom2realaddr(root)
            # Seek to start of pointer table
            rom.seek(addr)
            # Assume the first address we read also indicates the end of the pointer table
            pointers = [(addr, utils.read_short(rom))]
            end_addr = utils.rom2realaddr((root[0], pointers[0][1]))
            # Determine number of entries in list
            count = ((end_addr - addr) // 2)
            pointers += [(rom.tell(), utils.read_short(rom)) for i in range(0, count - 1)]

            output.write(f'SECTION "Tileset Script Table {root_idx}", ROMX[${root[1]:04X}], BANK[${root[0]:02X}]\n')
            output.write(f'TilesetScripts{root_idx}::\n')
            
            scripts = OrderedDict()
            addr_id_map = OrderedDict()
            for ptr_idx, ptr in enumerate(pointers):
                addr = ptr[1]
                if addr in addr_id_map:
                    ptr_id = addr_id_map[addr]
                else:
                    ptr_id = f"{root_idx:02X}_{ptr_idx:04X}"
                    if ptr_id in nametable:
                        ptr_id = nametable[ptr_id]
                    addr_id_map[addr] = ptr_id

                    # Read script if it's an new one
                    rom.seek(utils.rom2realaddr((root[0], addr)))
                    scripts[ptr_id] = [f"TilesetScript{ptr_id}::"]
                    while True:
                        b = utils.read_byte(rom)
                        cmd = commands.get(b, commands[None])
                        params = cmd.parser(rom)
                        
                        if params is not list:
                            params = [params]
                            if b not in commands:
                                params = [b] + params

                        params = [f"${i:02X}" for i in params if i is not None]

                        scripts[ptr_id].append(f"  {cmd.name} {','.join(params)}")

                        if cmd.is_end:
                            break

                output.write(f"  dw TilesetScript{ptr_id}\n")
            output.write('\n')

            for ptr_id in scripts:
                for line in scripts[ptr_id]:
                    output.write(f"{line}\n")
                output.write("\n")
